
[6.s081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)

[课程]([https://pdos.csail.mit.edu/6.828/2021/schedule.html](https://pdos.csail.mit.edu/6.828/2021/schedule.html))

阅读文档： https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html

## 0. 操作系统接口

一个*向其他运行中程序*提供服务的特殊程序。每一个运行中程序（称之为**进程**）都拥有*包含指令、数据、栈的内存空间* ， *指令*实现了程序的运算，*数据*是用于运算过程的变量，*栈*管理了程序的过程调用


**进程**通过**系统调用**使用内核服务，系统调用会进入内核，让内核执行服务然后返回。所以 **进程总是在用户空间和内核空间之间交替运行**。

内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间，内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

### 接口：

内核提供的一系列系统调用就是用户程序可见的操作系统接口

| 系统调用                      | 描述                   |
| ------------------------- | -------------------- |
| fork()                    | 创建进程                 |
| exit()                    | 结束当前进程               |
| wait()                    | 等待子进程结束              |
| kill(pid)                 | 结束 pid 所指进程          |
| getpid()                  | 获得当前进程 pid           |
| sleep(n)                  | 睡眠 n 秒               |
| exec(filename, *argv)     | 加载并执行一个文件            |
| sbrk(n)                   | 为进程内存空间增加 n 字节       |
| open(filename, flags)     | 打开文件，flags 指定读/写模式   |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf     |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件    |
| close(fd)                 | 关闭打开的 fd             |
| dup(fd)                   | 复制 fd                |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录               |
| mkdir(dirname)            | 创建新的目录               |
| mknod(name, major, minor) | 创建设备文件               |
| fstat(fd)                 | 返回文件信息               |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)     |
| unlink(filename)          | 删除文件                 |

shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。


###  进程和内存

xv6 进程的组成部分：

1. 用户内存空间： **（指令，数据，栈）**


2. 仅对内核可见的进程状态： 

- **xv6 是一个操作系统**，而不是一个普通的程序。它包含了操作系统的核心组件，如进程管理、内存管理、文件系统、设备驱动等。

#### 问题1： 

为什么我可以在我的操作系统上同时运行xv6来进行学习呢？

#### 回答1：

xv6 是作为一个 **虚拟机** 运行的，而不是直接在你的物理硬件上运行。以下是详细的解释：

因为使用了 QEMU： - **QEMU**：一个开源的虚拟化工具，可以模拟完整的计算机硬件。
类似于vm所以可以运行

---

####  xv6 *分时特性* ： 

**分时（Time-sharing）** 是 xv6 的一个重要特性，允许多个进程共享 CPU 资源，通过快速切换进程来实现“同时运行”的效果。以下是 xv6 分时特性的具体实现：

1. **轮转调度算法** ： [时间片轮转调度](https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)
2.  **上下文切换**
3.  **多进程并发**
4.  **系统调用支持**
5.  **中断机制**


关于 [多CPU，多核，多进程，多线程](https://www.cnblogs.com/raind/p/10077982.html "发布于 2018-12-06 17:26")

#### 问题2：

进程是怎么产生的？ 我们桌面上的一个软件点击打开的过程发生了什么

####  回答2：

 (1) **进程创建**

进程通常通过 **系统调用** 创建

 (2) **进程执行**

创建子进程后，通常会用 `exec()` 系统调用来加载一个新的程序到子进程的内存中，并开始执行。

 (3) **进程终止**

- 进程可以通过 `exit()` 系统调用主动终止，或者因为某些错误（如段错误）被操作系统强制终止。
    
- 父进程可以通过 `wait()` 系统调用等待子进程终止，并回收子进程的资源。





