
[6.s081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)

[课程]([https://pdos.csail.mit.edu/6.828/2021/schedule.html](https://pdos.csail.mit.edu/6.828/2021/schedule.html))

阅读文档： https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html

## 0. 操作系统接口

一个*向其他运行中程序*提供服务的特殊程序。每一个运行中程序（称之为**进程**）都拥有*包含指令、数据、栈的内存空间* ， *指令*实现了程序的运算，*数据*是用于运算过程的变量，*栈*管理了程序的过程调用


**进程**通过**系统调用**使用内核服务，系统调用会进入内核，让内核执行服务然后返回。所以 **进程总是在用户空间和内核空间之间交替运行**。

内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间，内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

### 接口

内核提供的一系列系统调用就是用户程序可见的操作系统接口

| 系统调用                      | 描述                   |
| ------------------------- | -------------------- |
| fork()                    | 创建进程                 |
| exit()                    | 结束当前进程               |
| wait()                    | 等待子进程结束              |
| kill(pid)                 | 结束 pid 所指进程          |
| getpid()                  | 获得当前进程 pid           |
| sleep(n)                  | 睡眠 n 秒               |
| exec(filename, *argv)     | 加载并执行一个文件            |
| sbrk(n)                   | 为进程内存空间增加 n 字节       |
| open(filename, flags)     | 打开文件，flags 指定读/写模式   |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf     |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件    |
| close(fd)                 | 关闭打开的 fd             |
| dup(fd)                   | 复制 fd                |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录               |
| mkdir(dirname)            | 创建新的目录               |
| mknod(name, major, minor) | 创建设备文件               |
| fstat(fd)                 | 返回文件信息               |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)     |
| unlink(filename)          | 删除文件                 |

shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。


###  进程和内存

xv6 进程的组成部分：

1. 用户内存空间： **（指令，数据，栈）**


2. 仅对内核可见的进程状态： 

- **xv6 是一个操作系统**，而不是一个普通的程序。它包含了操作系统的核心组件，如进程管理、内存管理、文件系统、设备驱动等。

#### 问题1： 

为什么我可以在我的操作系统上同时运行xv6来进行学习呢？

#### 回答1：

xv6 是作为一个 **虚拟机** 运行的，而不是直接在你的物理硬件上运行。以下是详细的解释：

因为使用了 QEMU： - **QEMU**：一个开源的虚拟化工具，可以模拟完整的计算机硬件。
类似于vm所以可以运行

---

####  xv6 *分时特性* ： 

**分时（Time-sharing）** 是 xv6 的一个重要特性，允许多个进程共享 CPU 资源，通过快速切换进程来实现“同时运行”的效果。以下是 xv6 分时特性的具体实现：

1. **轮转调度算法** ： [时间片轮转调度](https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)
2.  **上下文切换**
3.  **多进程并发**
4.  **系统调用支持**
5.  **中断机制**


关于 [多CPU，多核，多进程，多线程](https://www.cnblogs.com/raind/p/10077982.html "发布于 2018-12-06 17:26")

#### 问题2：

进程是怎么产生的？ 我们桌面上的一个软件点击打开的过程发生了什么

####  回答2：

 (1) **进程创建**

进程通常通过 **系统调用** 创建

 (2) **进程执行**

创建子进程后，通常会用 `exec()` 系统调用来加载一个新的程序到子进程的内存中，并开始执行。

 (3) **进程终止**

- 进程可以通过 `exit()` 系统调用主动终止，或者因为某些错误（如段错误）被操作系统强制终止。
    
- 父进程可以通过 `wait()` 系统调用等待子进程终止，并回收子进程的资源。


### fork() 进程创建

一次调用会返回两次： 一次是 *父进程* 一次是 *子进程*

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t pid;
    int x = 1;
    
    pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("child: x = %d\n", ++x);
        exit(0);
    } else if (pid > 0) {
        // Parent process
        printf("parent: x = %d\n", x);
        exit(0);
    } else {
        // Error in fork
        perror("fork failed");
        exit(1);
    }
    
    return 0;
}

```

返回结果：
~~~
parent: x=0
child: x=2
~~~

在 *shell* 中 执行  *./hello*  ：

shell看为父进程， 程序hello看为子进程，

父子进程都有*各自的空间互不干扰* 

程序和进程的*区别*：

程序是代码 ： 存储在磁盘上  在*执行* 是程序以段的形式 *存在于在内存的地址空间*

进程*为正在执行中程序的具体实例*

进程状态： 
1. 运行
2. 暂停
3. 终止


#### 对比
 
  对比fork 和 goroutine

| 特性       | `fork()`         | Goroutine   |
| -------- | ---------------- | ----------- |
| **创建单位** | 进程               | 轻量级线程       |
| **资源开销** | 高（复制整个进程）        | 低（共享地址空间）   |
| **通信方式** | 进程间通信（IPC）如管道、信号 | 通道（channel） |
| **调度**   | 操作系统调度           | Go 运行时调度    |
| **使用场景** | 需要完全独立执行的任务      | 高并发任务       |

#### 问题3：

`如果有两个fork()函数在放在上下句 那么第一个fork出来的子进程是调用两次fork还是一次fork呢？`

#### 回答3：

- **第一个 `fork()`**：创建子进程 C1。
    
- **第二个 `fork()`**：
    
    - 原始进程创建子进程 C2。
        
    - 子进程 C1 创建子进程 C3。
        

因此，第一个 `fork()` 创建的子进程 C1 会调用一次 `fork()`，创建子进程 C3。

**使用gcc编译程序**:

gcc  ~.c -o XXX

./XXX

**理解这段程序的执行顺序**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid;
    pid = fork();  // 创建子进程

    if (pid > 0) {
        // 父进程
        printf("parent: waiting for child to finish\n");
        pid_t child_pid = wait(NULL);  // 等待子进程完成
        printf("parent: child %d finished\n", child_pid);
    } else if (pid == 0) {
        // 子进程
        printf("child: doing some work\n");
        sleep(2);  // 模拟子进程工作
        printf("child: exiting\n");
        exit(0);  // 子进程退出
    } else {
        // fork 错误
        printf("fork error\n");
    }

    return 0;
}
```

   pid_t child_pid = wait(NULL);  // 等待子进程完成  *执行顺序*：
   1.  parent: waiting for child to finish
   2. 打印else里面的pid == 0也就是 子进程： child: doing some work  child: exiting
   3. wait收到了子进程的退出
   4. parent: child %d finished

**父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。**

父进程和子进程唯一的区别：

fork()返回的的进程号不一样 也就是返回两个值 父进程大于0 子进程小于0 


### exec()

加载并执行一个新的程序,替换当前进程的镜像,将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。

- **加载程序**：将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。
- **替换当前进程映像**：当前进程的代码、数据、堆栈等都会被新的程序替换。
- **执行新程序**：新程序开始执行，从其 `main()` 函数开始。
- **不返回**：一旦调用 `exec`，它会完全替换当前进程的执行代码，因此 **不会返回到原来的代码**（如果成功执行 `exec`）。

示例：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/ls", "-l", NULL};  // 执行的程序及参数
    execv("/bin/ls", args);  // 使用 execv 执行 ls 命令
    return 0;  // 如果 execv 执行成功，这行代码永远不会被执行
}

```


---


 `sleep 2000`  执行这句指令 的父进程是bash终端
 `pstree -p` 查看进程树
`echo $$`    是输出当前 shell 进程的 PID，这在一些进程管理和调试过程中很有用

结合 exec

`exec sleep 200`

这样使sleep进程替换了原来的bash进程
如果此时终止睡眠则终端直接关闭，因为sleep进程替换了bash进程

`vim test.sh` shell脚本

~~~
#! /bin/bash

sleep 200
~~~

添加执行权限：

`chmod +x test.sh`

`./test/sh`

执行脚本相当于： 用当前交互的Shell运行了一个shell子进程


#### I/O 和文件描述符

**文件描述符**是一个整数，它代表了一个进程可以读写的被内核管理的对象

文件描述符指向的对象称为“文件”

可以理解为key value 一个整数或者几个整数 对应一个文件

文件描述符和进程相伴相生

每个进程都有一个从0开始的文件描述符空间

0 1 2 

0： 标准输入： 键盘对应的存储空间

1： 标准输出 ： 输出到屏幕所对应的存储空间

`./test > test.txt` 将 程序 结果输出 到 文本文件中  

2： 标准出错 ： 出错信息打印到屏幕

shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符

系统调用 `read` 和 `write` 从文件描述符所指的文件中读或者写 n 个字节  `read(fd, buf, n)` 从 `fd` 读最多 n 个字节 将它们拷贝到 `buf` 中，然后返回读出的字节数

`write(fd, buf, n)` 写 `buf` 中的 n 个字节到 `fd` 并且返回实际写出的字节数


`cat` 的本质实现:

将数据从标准输入复制到标准输出

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```


`dup` 

复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符

示例：

```c
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```

`dup()` 主要用来复制文件描述符，方便使用多个描述符来操作同一个文件或 I/O 对象。它广泛用于 I/O 重定向、进程间共享文件描述符等场景。 



---

### 关于做题之前的一些建议

1. 了解对指针的运算

p[i] = *(p + i)

(int)p + 1，(int)(p + 1)

1. gdb调试

`make qemu-gdb` 

当 内核悬挂（例如，由于僵局）或无法进一步执行

使用GDB来找出其悬挂的位置 ：

  *run 'make qemu-gdb' in one window*  , *run gdb (riscv64-linux-gnu-gdb) in another windows*

理解程序：
```c
char*
strcpy(char *s, const char *t)
{
  char *os;

  os = s;
  while((*s++ = *t++) != 0)
    ;
  return os;
}
```


`make grade`  查看所有程序是否通过

`./grade-lab-util sleep`  单独 运行某个程序  `or`   `make GRADEFLAGS=sleep grade`

快速查找：

`grep "关键字" 文件名`

#### 1. 下载qemu慢

` cd /mnt/c/Users/30413/Downloads`

在wsl 可以 转换到本地目录

` cp qemu-7.2.16.tar.xz ~`直接就过来了

在wsl中下载qemu实在是太慢了

解压：

`tar xvJf qemu-7.2.16.tar.xz -C /opt/qemu`
`tar tvJf qemu-7.2.16.tar.xz`

成功运行了！

#### 2.`make grade`

解决xv6无法` make grade`

参考仓库：

https://github.com/heeyoung-choi/xv6-lab/blob/main/Makefile

强制删除在git中嵌套的仓库，以避免推送出现问题

`git rm -f --cached xv6-public`

---

### sleep.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
    if (argc < 2 || argc > 2 )
    {
    write(2,"only 1 arguments place write again\n",36);
    exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
```



### 管道

pipe() **创建了一个文件** 放在内存中 特殊的文件可供读写的一段存储空间

使用文件描述符去操作管道
int fd[2]：

fd的两个元素 fd[0]读取内容 fd[1]写内容 两个文件描述符操作一个管道 

*操作系统对于文件描述符的分配： 在所有的整数中取最小的整数 0 1 2 被使用过了 所以是 3和4分别为 fd[0] fd[1]*

Pipe(fd)

示例：

```c
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>

int main() {
    int fd[2];
    pipe (fd);
    int pid = fork();
   if (pid == 0) {
    //char* receive = (char*) malloc (100*sizeof(char));
    int *num = (int*) malloc (2*sizeof(int));
    read(fd[0], num, 2*sizeof(int));
    //printf("form father receive is :%s",receive);
    printf("the receive is %d,%d\n",*num,*(num + 1));
   }
   else {
   //char test[] = "hello world";
   int num[4] = {8,4,2,1};
   write(fd[1],num,4*sizeof(int));
   }
    return 0;
}
```


- `dup()` 系统调用用于复制一个文件描述符。 会创建一个新的文件描述符，指向与原始文件描述符相同的文件或资源。


#### 理解命令wc

示例程序:

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]); //利用文件描述符性质，这个dup会占用最小整数0的文件描述符
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```

#### 问题：

为什么要close(0)

- 当打开一个新文件或复制一个文件描述符时，系统会分配 **最小的可用文件描述符**。
    例如：
    - 如果文件描述符 `0` 被关闭，那么下一个可用的文件描述符就是 `0`。
    - 如果文件描述符 `0` 已经被占用，系统会分配下一个可用的文件描述符（如 `3`、`4` 等）。

为什么不直接使用p[0]呢？？



#### 解答：
 1. **确保 `dup(p[0])` 复制到文件描述符 `0`**

- 如果不关闭标准输入，文件描述符 `0` 仍然指向默认的标准输入（通常是终端）。
    
- 调用 `dup(p[0])` 时，系统会分配一个可用的文件描述符（如 `3`），而不是文件描述符 `0`。
    
- 这样，`wc` 命令仍然会从终端读取输入，而不是从管道读取数据。

1. **`wc` 命令默认从 标准输入（文件描述符 `0`） 读取数据**

- 如果直接使用 `p[0]`，`wc` 仍然会从标准输入读取数据，而不是从 `p[0]` 读取。
    
- 这意味着 `wc` 会等待用户从终端输入数据，而不是从管道读取数据。

 **（2）文件描述符的语义**

- 文件描述符 `0` 是标准输入，许多程序（如 `wc`、`cat` 等）都依赖于这一约定。
    
- 如果直接使用 `p[0]`，需要修改 `wc` 的源代码，使其从 `p[0]` 读取数据，而不是标准输入。这是不现实的，因为无法修改所有命令行工具的源代码。

- `wc` 命令仍然从标准输入读取数据，但它实际上是从管道读取数据。


总结： 关闭标准输入并使用 `dup(p[0])` 的目的是将管道的读端重定向到标准输入。


 `Ctrl+D`，如果你在命令行直接按 `Ctrl+D`，用于表示 **End of File (EOF, 文件结束)**


### pingpong.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"


int
main(int argc,char* argv[])
{
int fd[2];
pipe(fd);

if (fork() == 0)
{
read(fd[0],"received ping\n",14);
close(fd[1]);
write(fd[1],"pong",4);
exit(0)
}else
{
write(fd[1],"ping",4);
close(fd[0]);
read(fd[0],"recdived pong\n",5);
close(fd[0]);
}
wait(0);
exit(0);
}
```

第一次写出来的 错误代码！

最终修改：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

/*对于错误处理第一次整体都没有判断 read write pipe*/
int
main(int argc,char* argv[])
{

char buf[5];
int fd[2];

if (pipe(fd) < 0)
{
fprintf(2, "pipe failed\n");
exit(1);
}

if (fork() == 0)
{
read(fd[0],buf,4);
buf[4] = '\0';
printf("%d received %s\n",getpid(),buf);
close(fd[0]);
write(fd[1],"pong",4);
close(fd[1]);
exit(0);
}else
{
write(fd[1],"ping",4);
close(fd[1]);
read(fd[0],buf,4);
buf[4] = '\0'; // 添加空字符 忘记添加了
printf("%d: received %s\n",getpid(),buf);
close(fd[0]);
}
wait(0);
exit(0);
}
```


*我觉得这段程序可能会导致父子进程之间的相互竞争* 事实可能也是这样


重点：

正确使用 `pipe`、`fork`、`read` 和 `write`，以及关闭文件描述符和等待子进程完成


```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  int p1[2];
  int p2[2];
  if (-1 == pipe(p1) || -1 == pipe(p2)) {
    write(2, "error\n", 6);
  }

  if (fork() == 0) {
    char buf[1];
    read(p2[0], buf, 1);
    printf("%d: received ping\n", getpid());
    write(p1[1], "x", 1);
  } else {
    write(p2[1], "x", 1);
    char buf[1];
    read(p1[0], buf, 1);
    printf("%d: received pong\n", getpid());
  }
  exit(0);
}
```

这是取巧的一段代码


**第一次程序出现的问题：**
1. **父进程没有等待子进程完成**：
    
    - 父进程在读取 `pong` 后直接退出，没有调用 `wait(0)` 等待子进程完成。
        
    - 这可能导致子进程的输出被截断，或者父进程提前退出。
**第二次程序：**

添加wait（）等待子进程完成操作，避免造成竞争


---

#### 文件描述符的疑惑

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```

这段程序子进程使用1这个文件描述符后没有关闭，会不会导致父进程无法使用1这个文件描述符呢

#### 解答：

~~~
每个进程都有自己独立的文件描述符表。子进程通过 `fork()` 创建时，会继承父进程的文件描述符表，但子进程和父进程的文件描述符是相互独立的。子进程对文件描述符的操作（如写入、关闭）不会影响父进程的文件描述符。

当子进程调用 `exit()` 退出时，操作系统会关闭子进程打开的所有文件描述符。这些关闭操作仅限于子进程，不会影响父进程的文件描述符。
~~~


因为：

每个进程可以打开的文件描述符数量是有限的（由系统配置决定，可以通过 `ulimit -n` 查看）。如果不关闭文件描述符，可能会导致文件描述符泄漏，最终耗尽系统资源。

在编写pingpong.c时：

因为是对*管道的读写*，*管道的读写*操作是阻塞的。如果不关闭文件描述符，可能会导致进程一直等待，无法正常结束。

- 如果父进程不关闭 `fd[1]`，子进程的 `read(fd[0], buf, 4)` 可能会一直等待，因为父进程的 `fd[1]` 仍然打开，子进程无法确定父进程是否已经完成写入。
    
- 如果子进程不关闭 `fd[1]`，父进程的 `read(fd[0], buf, 4)` 可能会一直等待，因为子进程的 `fd[1]` 仍然打开，父进程无法确定子进程是否已经完成写入。

管道的设计遵循以下规则：

- 如果写入端（`fd[1]`）关闭，读取端（`fd[0]`）的 `read()` 会返回 `0`，表示没有更多数据可读（即文件结束，EOF）。
    
- 如果读取端（`fd[0]`）关闭，写入端（`fd[1]`）的 `write()` 会触发 `SIGPIPE` 信号，通常导致写入进程终止。

**这并不是通过信号实现的**，而是通过管道的文件描述符状态实现的。
如果父进程关闭了 `fd[1]`，子进程的 `read()` 会返回 `0`，表示管道已经关闭，没有更多数据可读。

#### **信号与管道的区别**

- **信号**：是一种异步通知机制，用于通知进程发生了某些事件（如 `SIGINT`、`SIGTERM` 等）。
    
- **管道**：是一种同步通信机制，通过文件描述符的状态（如关闭写入端）来通知读取端


### 文件系统

文件就是一个简单的字节数组， 

- `chdir()` 是一个系统调用，用于改变当前进程的工作目录。




### primes.c

第一次尝试
```c
void fork(int *father_pipe)
{
    int n;
    int pid = fork();
    int son_pipe[2];
    pipe[son_pipe];

    if (pid == 0)
    {
        while (1)
        {
            read(father_pipe[0], &n, sizeof(n));
            for (int i = 2; i < 35; i++)
            {
                if (n % i != 0)
                {
                    write(son_pipe[1], &n, sizeof(n));
                }
            }
        }
        close(father_pipe[0]);
        close(son_pipe[1]);
    }
    else
    {
        int st;
        wait(&st);
    }
}

int main(int argc, char *argv[])
{
    int fd[2];
    int buf[36];
    pipe[fd];

    for (int i = 2; i <= 35; i++)
    {
        write(fd[1], &i, sizeof(i));
    }
    close(fd[1]);
    f(fd);
}
```

我的思想：

父亲传入数据到管道的时候，在函数中应该需要先*fork出一个子进程* 来与*父进程通信*读取，并且我对从管道中读取数据也有点模糊，是一口气全部读出来，还是一个个读取然后做处理，我是想对所有的数字依次被2-35除然后筛选一层层向子进程传递，并最终打印出最终结果

以下是我的想法，并能求出的代码：


```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "stddef.h"


void create_child(int *input_pipe, int divisor) {
    int output_pipe[2];
    pipe(output_pipe); // 创建输出管道

    int pid = fork(); // 创建子进程
    if (pid == 0) {
        // 子进程
        close(input_pipe[1]); // 关闭父进程的写入端
        close(output_pipe[0]); // 关闭子进程的读取端

        int num;
        while (read(input_pipe[0], &num, sizeof(num)) > 0) {
            if (num % divisor != 0 || num == divisor) {
                // 如果不能被当前除数整除，或者数字是当前除数本身，传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            }
        }

        close(input_pipe[0]); // 关闭父进程的读取端
        close(output_pipe[1]); // 关闭子进程的写入端
        exit(0);
    } else {
        // 父进程
        close(input_pipe[0]); // 关闭父进程的读取端
        close(output_pipe[1]); // 关闭子进程的写入端

        if (divisor >= 35) {
            int num;
            while (read(output_pipe[0], &num, sizeof(num)) > 0) {
                printf("prime %d\n", num); // 打印质数
            }
            close(output_pipe[0]); // 关闭读取端
        } else {
            // 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
        }
    }
}

int main() {
    int fd[2];
    pipe(fd); // 创建初始管道

    // 将数字 2 到 35 写入管道
    for (int i = 2; i <= 35; i++) {
        write(fd[1], &i, sizeof(i));
    }
    close(fd[1]); // 关闭写入端

    // 创建第一个子进程，从 2 开始筛选
    create_child(fd, 2);

    // 父进程等待所有子进程结束
    while (wait(NULL) > 0);

    return 0;
}这段程序并不能正常打印出6.s081课程的素数题目的最终结果，我还应该怎么修改？
```

这段程序的错误：

1. 筛选条件

2. 递归逻辑问题：

正确的做法应该是每个子进程从输入管道中读取第一个数作为新的`divisor`（质数），然后用它筛选后续的数。而原代码强制`divisor`递增，导致后续进程可能使用非质数作为除数

3.  打印时机：

只有当`divisor >=35`时，父进程才会读取`output_pipe`并打印结果。这意味着只有最后一个进程才会打印，而实际上每个进程应负责打印自己筛选出的质数（即第一个接收到的数）





#### 问题 1：

read(input_pipe[0], &num, sizeof(num)) > 0 我并不理解有时候 在read和write中括号后面时常会出现 >0 =0 <0 都是什么意思？ 用while循环的目的又是什么

如何处理对于本身 例如： 2 % 2 == 0 ！


#### 解答 1：
1. read：
- **`> 0`**：成功读取了数据，返回值是实际读取的字节数。
    
- **`= 0`**：读取到文件结束（EOF），表示写入端已经关闭，没有更多数据可读。
    
- **`< 0`**：读取失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）。

2. write：

- **`> 0`**：成功写入了数据，返回值是实际写入的字节数。
    
- **`= 0`**：没有写入任何数据（通常不会发生，除非 `count` 为 0）。
    
- **`< 0`**：写入失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）

`while (read(input_pipe[0], &num, sizeof(num)) > 0)`：

- 持续从 `input_pipe[0]` 中读取数据。

- 如果读取成功（`read()` 返回 `> 0`），则处理数据。

回答2：

直接传递给下一个进程

#### 问题 2：

不理解这里的*数据是一次性全部传入管道一次性读取还是 父进程传入一个数据经过处理后然后再读取*

#### 解答 2：

1. 理解管道特性

管道是一种 **先进先出（FIFO）** 的通信机制。数据写入管道后，会按照写入的顺序依次被读取。管道的读写是 **阻塞的**：

- 如果管道为空，读取端会阻塞，直到有数据写入。
    
- 如果管道已满，写入端会阻塞，直到有数据被读取。

2. 代码中数据是一次性全部写入管道的， 当父进程*关闭写入端，表示数据写入完成*。
3. - 子进程从管道中 **逐个读取数据**，而不是一次性读取所有数据。
- 每读取一个数据，就根据 `divisor` 进行筛选，并将筛选后的数据写入下一个管道。

子进程：
- **逐个处理**：
    
    - 每个子进程从管道中 **逐个读取数据**，处理后再写入下一个管道。
        
    - 数据是 **流式处理** 的，而不是一次性全部读取。
        
- **批量处理**：
    
    - 如果管道中有多个数据，子进程会逐个读取并处理，直到管道为空。

#### 核心代码：

```c
 while (read(input_pipe[0], &num, sizeof(num)) > 0) {
            if (num == divisor) {
                // 如果是当前除数本身，直接传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            } else if (num % divisor != 0) {
                // 如果不能被当前除数整除，传递给下一个子进程
                write(output_pipe[1], &num, sizeof(num));
            }
        }
```



为什么可以持续的读，可以自动检测读完吗？

```c
 while (read(output_pipe[0], &num, sizeof(num)) > 0) {
                printf("primes: %d\n", num); // 打印质数
            }
            close(output_pipe[0]); // 关闭读取端
        } else {
            // 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
```

*重点解释：*

~~~
管道的写入端关闭

 当父进程写入数据并关闭写入端时，管道的写入端会被标记为关闭。
    
 关闭写入端后，读取端的 `read()` 行为会发生变化：
    
 如果管道中还有数据，`read()` 会继续读取数据。
        
 如果管道中没有数据，`read()` 会返回 `0`，表示写入端已经关闭，没有更多数据可读。
~~~

~~~
- 管道的内部实现会跟踪写入端的状态。
    
- 当写入端关闭时，操作系统会通知读取端，表示没有更多数据会写入管道。
    
- 如果读取端尝试读取数据，但管道中没有数据且写入端已关闭，`read()` 会返回 `0`。
~~~



#### 出乎意料

这段程序并没有成功打印出结果！


---

重新修改 primes.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void create_child(int parent_fd[]) {
    int p;
    // 读取第一个数字，它一定是质数
    if (read(parent_fd[0], &p, sizeof(p)) == 0) {
        close(parent_fd[0]);
        exit(0);
    }
    printf("prime %d\n", p); // 立即打印当前质数

    int child_fd[2];
    pipe(child_fd);

    if (fork() == 0) {
        // 子进程：关闭不必要的文件描述符，递归处理
        close(parent_fd[0]);
        close(child_fd[1]);
        create_child(child_fd);
        exit(0);
    } else {
        // 父进程：过滤并传递剩余数字
        close(child_fd[0]);
        int num;
        while (read(parent_fd[0], &num, sizeof(num)) > 0) {
            if (num % p != 0) {
                write(child_fd[1], &num, sizeof(num));
            }
        }
        close(parent_fd[0]);
        close(child_fd[1]);
        wait(0); // 等待子进程结束
    }
}

int main() {
    int initial_fd[2];
    pipe(initial_fd);

    for (int i = 2; i <= 35; i++) {
        write(initial_fd[1], &i, sizeof(i));
    }
    close(initial_fd[1]);

    create_child(initial_fd);

    // 确保所有子进程结束
    while (wait(0) > 0);
    exit(0);
}
```

疑问：

```c
while (read(parent_fd[0], &num, sizeof(num)) > 0) { if (num % p != 0) { write(child_fd[1], &num, sizeof(num)); } } 
```

 这段程序不是也会把2等过滤掉吗

**管道是队列结构**​  
管道（Pipe）本质上是一个**先进先出（FIFO）的字节流**。每次调用 `read` 读取数据时，读取过的数据会从管道中移除，后续的 `read` 操作只会读取未被读取的数据。

### 输出重定向

#### redirect.c

![[重定向.png]]


---

你不必成为专家， 你花费大量时间开发维护和调试，会了解很多操作系统的知识，
 ls > out 输出重定向
 echo hello > out
 cat < out
 子进程调用exit(1) -> 父进程会接受到子进程的退出   
 exec会丢弃所有复制的内存，并将其替换为
 思考fork的副本复制 复制了所有的内存 所花费的时间
虚拟内存映射
为子进程分配权重

观看完第一集视频，看完第一章内容，还剩两道题没有做

---

 
### find.c

前置提示： 了解如何读取目 录



```c
      
```