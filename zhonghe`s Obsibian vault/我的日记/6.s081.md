
[6.s081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)

[课程]([https://pdos.csail.mit.edu/6.828/2021/schedule.html](https://pdos.csail.mit.edu/6.828/2021/schedule.html))

阅读文档： https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html

## 0. 操作系统接口

一个*向其他运行中程序*提供服务的特殊程序。每一个运行中程序（称之为**进程**）都拥有*包含指令、数据、栈的内存空间* ， *指令*实现了程序的运算，*数据*是用于运算过程的变量，*栈*管理了程序的过程调用


**进程**通过**系统调用**使用内核服务，系统调用会进入内核，让内核执行服务然后返回。所以 **进程总是在用户空间和内核空间之间交替运行**。

内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间，内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

### 接口

内核提供的一系列系统调用就是用户程序可见的操作系统接口

| 系统调用                      | 描述                   |
| ------------------------- | -------------------- |
| fork()                    | 创建进程                 |
| exit()                    | 结束当前进程               |
| wait()                    | 等待子进程结束              |
| kill(pid)                 | 结束 pid 所指进程          |
| getpid()                  | 获得当前进程 pid           |
| sleep(n)                  | 睡眠 n 秒               |
| exec(filename, *argv)     | 加载并执行一个文件            |
| sbrk(n)                   | 为进程内存空间增加 n 字节       |
| open(filename, flags)     | 打开文件，flags 指定读/写模式   |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf     |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件    |
| close(fd)                 | 关闭打开的 fd             |
| dup(fd)                   | 复制 fd                |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录               |
| mkdir(dirname)            | 创建新的目录               |
| mknod(name, major, minor) | 创建设备文件               |
| fstat(fd)                 | 返回文件信息               |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)     |
| unlink(filename)          | 删除文件                 |

shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。


###  进程和内存

xv6 进程的组成部分：

1. 用户内存空间： **（指令，数据，栈）**


2. 仅对内核可见的进程状态： 

- **xv6 是一个操作系统**，而不是一个普通的程序。它包含了操作系统的核心组件，如进程管理、内存管理、文件系统、设备驱动等。

#### 问题1： 

为什么我可以在我的操作系统上同时运行xv6来进行学习呢？

#### 回答1：

xv6 是作为一个 **虚拟机** 运行的，而不是直接在你的物理硬件上运行。以下是详细的解释：

因为使用了 QEMU： - **QEMU**：一个开源的虚拟化工具，可以模拟完整的计算机硬件。
类似于vm所以可以运行

---

####  xv6 *分时特性* ： 

**分时（Time-sharing）** 是 xv6 的一个重要特性，允许多个进程共享 CPU 资源，通过快速切换进程来实现“同时运行”的效果。以下是 xv6 分时特性的具体实现：

1. **轮转调度算法** ： [时间片轮转调度](https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)
2.  **上下文切换**
3.  **多进程并发**
4.  **系统调用支持**
5.  **中断机制**


关于 [多CPU，多核，多进程，多线程](https://www.cnblogs.com/raind/p/10077982.html "发布于 2018-12-06 17:26")

#### 问题2：

进程是怎么产生的？ 我们桌面上的一个软件点击打开的过程发生了什么

####  回答2：

 (1) **进程创建**

进程通常通过 **系统调用** 创建

 (2) **进程执行**

创建子进程后，通常会用 `exec()` 系统调用来加载一个新的程序到子进程的内存中，并开始执行。

 (3) **进程终止**

- 进程可以通过 `exit()` 系统调用主动终止，或者因为某些错误（如段错误）被操作系统强制终止。
    
- 父进程可以通过 `wait()` 系统调用等待子进程终止，并回收子进程的资源。


### fork() 进程创建

一次调用会返回两次： 一次是 *父进程* 一次是 *子进程*

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t pid;
    int x = 1;
    
    pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("child: x = %d\n", ++x);
        exit(0);
    } else if (pid > 0) {
        // Parent process
        printf("parent: x = %d\n", x);
        exit(0);
    } else {
        // Error in fork
        perror("fork failed");
        exit(1);
    }
    
    return 0;
}

```

返回结果：
~~~
parent: x=0
child: x=2
~~~

在 *shell* 中 执行  *./hello*  ：

shell看为父进程， 程序hello看为子进程，

父子进程都有*各自的空间互不干扰* 

程序和进程的*区别*：

程序是代码 ： 存储在磁盘上  在*执行* 是程序以段的形式 *存在于在内存的地址空间*

进程*为正在执行中程序的具体实例*

进程状态： 
1. 运行
2. 暂停
3. 终止


#### 对比
 
  对比fork 和 goroutine

| 特性       | `fork()`         | Goroutine   |
| -------- | ---------------- | ----------- |
| **创建单位** | 进程               | 轻量级线程       |
| **资源开销** | 高（复制整个进程）        | 低（共享地址空间）   |
| **通信方式** | 进程间通信（IPC）如管道、信号 | 通道（channel） |
| **调度**   | 操作系统调度           | Go 运行时调度    |
| **使用场景** | 需要完全独立执行的任务      | 高并发任务       |

#### 问题3：

`如果有两个fork()函数在放在上下句 那么第一个fork出来的子进程是调用两次fork还是一次fork呢？`

#### 回答3：

- **第一个 `fork()`**：创建子进程 C1。
    
- **第二个 `fork()`**：
    
    - 原始进程创建子进程 C2。
        
    - 子进程 C1 创建子进程 C3。
        

因此，第一个 `fork()` 创建的子进程 C1 会调用一次 `fork()`，创建子进程 C3。

**使用gcc编译程序**:

gcc  ~.c -o XXX

./XXX

**理解这段程序的执行顺序**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid;
    pid = fork();  // 创建子进程

    if (pid > 0) {
        // 父进程
        printf("parent: waiting for child to finish\n");
        pid_t child_pid = wait(NULL);  // 等待子进程完成
        printf("parent: child %d finished\n", child_pid);
    } else if (pid == 0) {
        // 子进程
        printf("child: doing some work\n");
        sleep(2);  // 模拟子进程工作
        printf("child: exiting\n");
        exit(0);  // 子进程退出
    } else {
        // fork 错误
        printf("fork error\n");
    }

    return 0;
}
```

   pid_t child_pid = wait(NULL);  // 等待子进程完成  *执行顺序*：
   1.  parent: waiting for child to finish
   2. 打印else里面的pid == 0也就是 子进程： child: doing some work  child: exiting
   3. wait收到了子进程的退出
   4. parent: child %d finished

**父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。**

父进程和子进程唯一的区别：

fork()返回的的进程号不一样 也就是返回两个值 父进程大于0 子进程小于0 


### exec()

加载并执行一个新的程序,替换当前进程的镜像,将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。

- **加载程序**：将指定的可执行文件（如 `./a.out`）加载到当前进程的地址空间中。
- **替换当前进程映像**：当前进程的代码、数据、堆栈等都会被新的程序替换。
- **执行新程序**：新程序开始执行，从其 `main()` 函数开始。
- **不返回**：一旦调用 `exec`，它会完全替换当前进程的执行代码，因此 **不会返回到原来的代码**（如果成功执行 `exec`）。

示例：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/ls", "-l", NULL};  // 执行的程序及参数
    execv("/bin/ls", args);  // 使用 execv 执行 ls 命令
    return 0;  // 如果 execv 执行成功，这行代码永远不会被执行
}

```


---


 `sleep 2000`  执行这句指令 的父进程是bash终端
 `pstree -p` 查看进程树
`echo $$`    是输出当前 shell 进程的 PID，这在一些进程管理和调试过程中很有用

结合 exec

`exec sleep 200`

这样使sleep进程替换了原来的bash进程
如果此时终止睡眠则终端直接关闭，因为sleep进程替换了bash进程

`vim test.sh` shell脚本

~~~
#! /bin/bash

sleep 200
~~~

添加执行权限：

`chmod +x test.sh`

`./test/sh`

执行脚本相当于： 用当前交互的Shell运行了一个shell子进程


#### I/O 和文件描述符

**文件描述符**是一个整数，它代表了一个进程可以读写的被内核管理的对象

文件描述符指向的对象称为“文件”

可以理解为key value 一个整数或者几个整数 对应一个文件

文件描述符和进程相伴相生

每个进程都有一个从0开始的文件描述符空间

0 1 2 

0： 标准输入： 键盘对应的存储空间

1： 标准输出 ： 输出到屏幕所对应的存储空间

`./test > test.txt` 将 程序 结果输出 到 文本文件中  

2： 标准出错 ： 出错信息打印到屏幕

shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符

系统调用 `read` 和 `write` 从文件描述符所指的文件中读或者写 n 个字节  `read(fd, buf, n)` 从 `fd` 读最多 n 个字节 将它们拷贝到 `buf` 中，然后返回读出的字节数

`write(fd, buf, n)` 写 `buf` 中的 n 个字节到 `fd` 并且返回实际写出的字节数


`cat` 的本质实现:

将数据从标准输入复制到标准输出

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```


`dup` 

复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符

示例：

```c
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```

`dup()` 主要用来复制文件描述符，方便使用多个描述符来操作同一个文件或 I/O 对象。它广泛用于 I/O 重定向、进程间共享文件描述符等场景。 



---

### 关于做题之前的一些建议

1. 了解对指针的运算

p[i] = *(p + i)

(int)p + 1，(int)(p + 1)

1. gdb调试

`make qemu-gdb` 

当 内核悬挂（例如，由于僵局）或无法进一步执行

使用GDB来找出其悬挂的位置 ：

  *run 'make qemu-gdb' in one window*  , *run gdb (riscv64-linux-gnu-gdb) in another windows*

理解程序：
```c
char*
strcpy(char *s, const char *t)
{
  char *os;

  os = s;
  while((*s++ = *t++) != 0)
    ;
  return os;
}
```


`make grade`  查看所有程序是否通过

`./grade-lab-util sleep`  单独 运行某个程序  `or`   `make GRADEFLAGS=sleep grade`

快速查找：

`grep "关键字" 文件名`

#### 1. 下载qemu慢

` cd /mnt/c/Users/30413/Downloads`

在wsl 可以 转换到本地目录

` cp qemu-7.2.16.tar.xz ~`直接就过来了

在wsl中下载qemu实在是太慢了

解压：

`tar xvJf qemu-7.2.16.tar.xz -C /opt/qemu`
`tar tvJf qemu-7.2.16.tar.xz`

成功运行了！

#### 2.`make grade`

解决xv6无法` make grade`

参考仓库：

https://github.com/heeyoung-choi/xv6-lab/blob/main/Makefile

强制删除在git中嵌套的仓库，以避免推送出现问题

`git rm -f --cached xv6-public`

---

### sleep.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
    if (argc < 2 || argc > 2 )
    {
    write(2,"only 1 arguments place write again\n",36);
    exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
```


### 管道

pipe() **创建了一个文件** 放在内存中 特殊的文件可供读写的一段存储空间

使用文件描述符去操作管道
int fd[2]：

fd的两个元素 fd[0]读取内容 fd[1]写内容 两个文件描述符操作一个管道 

*操作系统对于文件描述符的分配： 在所有的整数中取最小的整数 0 1 2 被使用过了 所以是 3和4分别为 fd[0] fd[1]*

Pipe(fd)

示例：

```c
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>

int main() {
    int fd[2];
    pipe (fd);
    int pid = fork();
   if (pid == 0) {
    //char* receive = (char*) malloc (100*sizeof(char));
    int *num = (int*) malloc (2*sizeof(int));
    read(fd[0], num, 2*sizeof(int));
    //printf("form father receive is :%s",receive);
    printf("the receive is %d,%d\n",*num,*(num + 1));
   }
   else {
   //char test[] = "hello world";
   int num[4] = {8,4,2,1};
   write(fd[1],num,4*sizeof(int));
   }
    return 0;
}
```


- `dup()` 系统调用用于复制一个文件描述符。 会创建一个新的文件描述符，指向与原始文件描述符相同的文件或资源。


#### 理解命令wc

示例程序:

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]); //利用文件描述符性质，这个dup会占用最小整数0的文件描述符
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```

#### 问题：

为什么要close(0)

- 当打开一个新文件或复制一个文件描述符时，系统会分配 **最小的可用文件描述符**。
    例如：
    - 如果文件描述符 `0` 被关闭，那么下一个可用的文件描述符就是 `0`。
    - 如果文件描述符 `0` 已经被占用，系统会分配下一个可用的文件描述符（如 `3`、`4` 等）。

为什么不直接使用p[0]呢？？



#### 解答：
 1. **确保 `dup(p[0])` 复制到文件描述符 `0`**

- 如果不关闭标准输入，文件描述符 `0` 仍然指向默认的标准输入（通常是终端）。
    
- 调用 `dup(p[0])` 时，系统会分配一个可用的文件描述符（如 `3`），而不是文件描述符 `0`。
    
- 这样，`wc` 命令仍然会从终端读取输入，而不是从管道读取数据。

1. **`wc` 命令默认从 标准输入（文件描述符 `0`） 读取数据**

- 如果直接使用 `p[0]`，`wc` 仍然会从标准输入读取数据，而不是从 `p[0]` 读取。
    
- 这意味着 `wc` 会等待用户从终端输入数据，而不是从管道读取数据。

 **（2）文件描述符的语义**

- 文件描述符 `0` 是标准输入，许多程序（如 `wc`、`cat` 等）都依赖于这一约定。
    
- 如果直接使用 `p[0]`，需要修改 `wc` 的源代码，使其从 `p[0]` 读取数据，而不是标准输入。这是不现实的，因为无法修改所有命令行工具的源代码。

- `wc` 命令仍然从标准输入读取数据，但它实际上是从管道读取数据。


总结： 关闭标准输入并使用 `dup(p[0])` 的目的是将管道的读端重定向到标准输入。


 `Ctrl+D`，如果你在命令行直接按 `Ctrl+D`，用于表示 **End of File (EOF, 文件结束)**


### pingpong.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"


int
main(int argc,char* argv[])
{
int fd[2];
pipe(fd);

if (fork() == 0)
{
read(fd[0],"received ping\n",14);
close(fd[1]);
write(fd[1],"pong",4);
exit(0)
}else
{
write(fd[1],"ping",4);
close(fd[0]);
read(fd[0],"recdived pong\n",5);
close(fd[0]);
}
wait(0);
exit(0);
}
```

第一次写出来的 错误代码！

最终修改：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

/*对于错误处理第一次整体都没有判断 read write pipe*/
int
main(int argc,char* argv[])
{

char buf[5];
int fd[2];

if (pipe(fd) < 0)
{
fprintf(2, "pipe failed\n");
exit(1);
}

if (fork() == 0)
{
read(fd[0],buf,4);
buf[4] = '\0';
printf("%d received %s\n",getpid(),buf);
close(fd[0]);
write(fd[1],"pong",4);
close(fd[1]);
exit(0);
}else
{
write(fd[1],"ping",4);
close(fd[1]);
read(fd[0],buf,4);
buf[4] = '\0'; // 添加空字符 忘记添加了
printf("%d: received %s\n",getpid(),buf);
close(fd[0]);
}
wait(0);
exit(0);
}
```


*我觉得这段程序可能会导致父子进程之间的相互竞争* 事实可能也是这样


重点：

正确使用 `pipe`、`fork`、`read` 和 `write`，以及关闭文件描述符和等待子进程完成

**第一次程序出现的问题：**
1. **父进程没有等待子进程完成**：
    
    - 父进程在读取 `pong` 后直接退出，没有调用 `wait(0)` 等待子进程完成。
        
    - 这可能导致子进程的输出被截断，或者父进程提前退出。
**第二次程序：**

添加wait（）等待子进程完成操作，避免造成竞争
